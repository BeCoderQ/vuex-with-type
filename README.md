## ä½œç”¨
vuex-with-typeæ˜¯ä¸ºäº†è§£å†³vuex4ä»¥ä¸‹ç‰ˆæœ¬åœ¨typescriptç¼–å†™æ—¶æ— æ³•æ­£ç¡®æ¨æ–­å‡ºç±»å‹çš„é—®é¢˜ï¼Œç›®å‰æˆ‘æš‚æ—¶åªå†™äº†stateä¸mutationçš„ç±»å‹æ¨æ–­ã€‚

## åŸç†
vuex4ä»¥ä¸‹ä¸èƒ½æ­£ç¡®æ¨æ–­å‡ºç±»å‹çš„æœ¬è´¨åŸå› æ˜¯å› ä¸ºvuexå®˜æ–¹çš„å£°æ˜æ–‡ä»¶åœ¨åˆå¹¶Vueæ—¶å°†`$store`çš„ç±»å‹æ¨æ–­å†™ä¸ºäº†`Store<any>`ï¼Œè¿™å¯¼è‡´æˆ‘ä»¬åç»­çš„å£°æ˜åˆå¹¶
éƒ½æ— æ³•æ”¶çª„ç±»å‹ï¼Œå› æ­¤stateçš„ç±»å‹ä¸ºanyï¼Œcommitçš„ç±»å‹ä¹Ÿæ— æ³•å‡†ç¡®æ¨æ–­ã€‚æˆ‘çš„æ–¹æ³•å¾ˆç®€å•ï¼Œè¯»å–node_modulesä¸­vuexçš„è¿™ä¸ªå£°æ˜æ–‡ä»¶ï¼Œå°†å¤šä½™çš„éƒ¨åˆ†å»æ‰ï¼Œ
ç„¶åè‡ªåŠ¨ç”Ÿæˆå¯ä»¥ç²¾ç¡®æ¨æ–­å‡ºstateä¸commitçš„å£°æ˜æ–‡ä»¶ã€‚

## ä½¿ç”¨æ–¹æ³•
å…¨å±€ä½¿ç”¨`vwt`å‘½ä»¤ï¼š
- vwt handbook  ğŸ‘‰ **æŸ¥çœ‹æ‰€æœ‰å‘½ä»¤è¯´æ˜**
- vwt config  ğŸ‘‰ **ç”Ÿæˆé…ç½®æ–‡ä»¶ ä»¥é…ç½®æ–‡ä»¶çš„å½¢å¼è¿›è¡Œæºç ç”Ÿæˆ**
- vwt init  ğŸ‘‰ **åˆå§‹åŒ–å¹¶ç”Ÿæˆå£°æ˜æ–‡ä»¶ å¦‚æœæœ‰configå‘½ä»¤ç”Ÿæˆçš„æ–‡ä»¶ï¼Œåˆ™ä¼šä¼˜å…ˆä½¿ç”¨å®ƒ**

### ç»†èŠ‚è¯´æ˜
è€ƒè™‘åˆ°ä¸­é€”ä½¿ç”¨æ­¤åŒ…æˆ–è€…æ˜¯ä¸æƒ³ä½¿ç”¨é»˜è®¤çš„æ¨¡æ¿è¦†ç›–ä½ çš„`vuex/index.ts`ï¼Œå¯ä»¥é€‰æ‹©åœ¨æç¤ºæ˜¯å¦è¦†ç›–æ—¶è¾“å…¥noï¼Œä¹‹åä¼šåœ¨vuexçš„æ–‡ä»¶ä¸‹ç”Ÿæˆä¸€ä¸ªtypex.tsçš„æ–‡ä»¶ï¼Œè¿™æ˜¯ä¸€ä¸ªè¾…åŠ©æ€§çš„ç±»å‹æ–‡ä»¶ï¼Œæ‚¨å¯ä»¥åœ¨
è‡ªå·±åˆ›å»ºçš„`vuex/index.ts`ä¸­å¼•ç”¨å…¶ä¸­çš„æ˜ å°„å·¥å…·`NonNeverState`ä¸`isOwnKey`ï¼Œå¦ä¸€ä¸ªç±»å‹`DealNeverType`æ˜¯ç”¨äºå¤„ç†å¯¹è±¡ä¸­é”™è¯¯æ¨æ–­å‡º`never`ç±»å‹çš„å·¥å…·ã€‚

#### ç¤ºä¾‹
- é€‰æ‹©ä¸è¦†ç›–ï¼š

```typescript
import Vue from 'vue'
import Vuex from 'vuex'
// è¿™é‡Œå¼•å…¥
import { NonNeverState, isOwnKey } from "./typex";

Vue.use(Vuex)

const state = {
  token: "",
  openId: "",
  name: "",
  appId: "1"
}

// è¿™é‡Œå¯¼å‡ºçš„å­—æ®µåTStateå°±æ˜¯åˆå§‹åŒ–æ—¶ä½ è®¾ç½®çš„
export type TState = NonNeverState<typeof state>

export const mutations = {
  SET_STATE(state: TState, obj: Partial<TState>) {
    for (const key in obj) {
      if (isOwnKey(key, obj)) {
        state[key] = obj[key];
      }
    }
  },
  SET_NAME(state: TState, v: string) {
    state.name = v;
  }
};

// Mutationçš„ç±»å‹ä¸€æ ·éœ€è¦ä½ å¯¼å‡º
export type TMutation = typeof mutations;

export default new Vuex.Store<TState>({
  state,
  mutations
});

```

- é€‰æ‹©è¦†ç›–ï¼š

å¦‚æœè¾“å…¥äº†yesï¼Œé‚£ä¹ˆé»˜è®¤çš„æ¨¡æ¿ä¼šè¦†ç›–ä½ å·²æœ‰çš„æ–‡ä»¶ï¼Œä½†ä¹‹åä½ ä¸éœ€è¦æœ‰å…¶ä»–æ“ä½œã€‚

å¦‚æœä¸€åˆ‡æ­£å¸¸ï¼Œè¿™æ—¶å€™ä½ å°±å¯ä»¥æ‹¿åˆ°æ­£ç¡®çš„ç±»å‹äº†ï¼

## effect
vuex-with-type is to solve the problem that vuex4 and lower versions cannot correctly infer the type when writing typescript. For now, I only wrote the type inference of state and mutation for the time being.

## prieiple
The essential reason why the type cannot be correctly inferred under vuex4 is because the official vuex declaration file writes the type inference of `$store` as `Store<any>` when merging Vue, which leads to the merger of our subsequent declarations
Neither can narrow the type, so the type of state is any, and the type of commit cannot be accurately inferred. My method is very simple. Reading this declaration file of vuex in node_modules then delete extra part.Then generate a declaration file that can accurately infer the state and commit automatically.

## usage
Use the `vwt` command globally:
- vwt handbook ğŸ‘‰  **View all command descriptions**
- vwt config  ğŸ‘‰ **Generate configuration file**
- vwt init  ğŸ‘‰ **Initialize and generate a declaration file. If there is a file generated by the config command, it will be used first**

### Details

Considering that you use this package halfway or you donâ€™t want to use the default template to overwrite your `vuex/index.ts`, you can choose to enter "no" when prompted whether to overwrite, and then a `typex.ts` file will be generated under the vuex file. It's an auxiliary type file, you can find
The mapping tools `NonNeverState` and `isOwnKey`.Import them to the `vuex/index.ts`. The other type `DealNeverType` is a tool used to infer the `never` type from errors in the object.

if everything is ok, you can get correct type now.

This is my first time writing an open source library, Sorry for not doing well.